<div class="barsArea" >
    <!-- <h1 class="" style="animation-fill-mode: forwards ;animation-duration: 10s ; animation-name:down">An animated element</h1> -->
    <!-- <div class="h-bar"></div> -->
    <table  >
        <tr  >
    <td *ngFor="let bar of bars"  >
<div  
 [ngClass]=" bar.right? ['bar', 'animate__animated','animate__slideInLeft'] : bar.left? ['bar', 'animate__animated','animate__slideInRight']:bar.overRight? ['bar','animate__animated',' animate__fadeInLeft']:['bar']"
    
     [ngStyle]="{'height.px':bar.height , 'margin-bottom':'100px' ,   
         'background-color': bar.color=='N'? 'pink' : bar.color=='G'? '#90ee90 ' : bar.color=='P'? 'orange' : bar.color=='Pi'? '#ffef00 ':' #FFC0CB' , 'z-index':'-9', 'animation-name' : bar.overLeft? 'leftX': bar.overRight? 'rightX': null, 'animation-fill-mode': 'forwards' ,'animation-duration': (S[0]/1000)+'s' }"
         
         ></div>
    </td>
</tr>

</table>
</div>




<div class="container-info">
    <table>
        <tr style="vertical-align: bottom;">
            <td>
                <div class="sub-container">
                    <h1>Time Complexity</h1>
                    <p style="font-family: 'Prompt', sans-serif;">Time complexity is defined as the amount of time taken by an algorithm to run, as a function of the length of the input. It measures the time taken to execute each statement of code in an algorithm. It is not going to examine the total execution time of an algorithm. Rather, it is going to give information about the variation (increase or decrease) in execution time when the number of operations (increase or decrease) in an algorithm. Yes, as the definition says, the amount of time taken is a function of the length of input only.</p>
                </div>
                <div class="sub-container">
                    <h1>Space Complexity</h1>
                    <p>Space complexity is a parallel concept to time complexity. If we need to create an array of size n, this will require O(n) space. If we create a two-dimensional array of size n*n, this will require O(n2) space.</p>
                </div>
            </td >
            <td style="vertical-align: top;">
                <img style="width:400px; margin-top:90px " src="https://he-s3.s3.amazonaws.com/media/uploads/317c55e.png" alt="Girl in a jacket">
            </td>

        </tr>
       
       
    </table>
    
</div>
<div class="container-info">
    
    <table>
        <tr style="vertical-align: top; ">
            <td>
                <div class="sub-container ">
                    <h1>Bubble Sort</h1>
                    <p style="font-family: 'Prompt', sans-serif; ">Bubble sort works on the repeatedly swapping of adjacent elements until they are not in the intended order. It is called bubble sort because the movement of array elements is just like the movement of air bubbles in the water. Bubbles in water rise up to the surface; similarly, the array elements in bubble sort move to the end in each iteration.

                    </p>
                    <p style="font-family: 'Prompt', sans-serif;">   Although it is simple to use, it is primarily used as an educational tool because the performance of bubble sort is poor in the real world. It is not suitable for large data sets. The average and worst-case complexity of Bubble sort is O(n2), where n is a number of items.</p>
                </div>
                <!-- <div class="sub-container">
                    <h1>Space Complexity</h1>
                    <p>Space complexity is a parallel concept to time complexity. If we need to create an array of size n, this will require O(n) space. If we create a two-dimensional array of size n*n, this will require O(n2) space.</p>
                </div> -->
            </td >
            <td style="vertical-align: top;">
                <img style="width:400px; margin-top:90px " src="https://www.happycoders.eu/wp-content/uploads/2020/07/Bubble_Sort_runtime-944x495.png" alt="Girl in a jacket">
            </td>

        </tr>
       
       
    </table>
</div>



<div class="container-info">
    
    <table>
        <tr style="vertical-align: top; ">
            <td>
                <div class="sub-container ">
                    <h1>Insertion Sort</h1>
                    <p style="font-family: 'Prompt', sans-serif; ">Insertion sort works similar to the sorting of playing cards in hands. It is assumed that the first card is already sorted in the card game, and then we select an unsorted card. If the selected unsorted card is greater than the first card, it will be placed at the right side; otherwise, it will be placed at the left side. Similarly, all unsorted cards are taken and put in their exact place.

                    </p>
                    <p style="font-family: 'Prompt', sans-serif;">  The same approach is applied in insertion sort. The idea behind the insertion sort is that first take one element, iterate it through the sorted array. Although it is simple to use, it is not appropriate for large data sets as the time complexity of insertion sort in the average case and worst case is O(n2), where n is the number of items. Insertion sort is less efficient than the other sorting algorithms like heap sort, quick sort, merge sort, etc.</p>
                </div>
                <!-- <div class="sub-container">
                    <h1>Space Complexity</h1>
                    <p>Space complexity is a parallel concept to time complexity. If we need to create an array of size n, this will require O(n) space. If we create a two-dimensional array of size n*n, this will require O(n2) space.</p>
                </div> -->
            </td >
            <td style="vertical-align: top;">
                <img style="width:400px; margin-top:90px " src="https://www.happycoders.eu/wp-content/uploads/2020/05/Insertion_Sort_runtime-v2.png" alt="Girl in a jacket">
            </td>

        </tr>
       
       
    </table>
</div>


 
<div class="container-info">
    
    <table>
        <tr style="vertical-align: top; ">
            <td>
                <div class="sub-container ">
                    <h1>Quick Sort</h1>
                    <p style="font-family: 'Prompt', sans-serif; "> Quicksort is the widely used sorting algorithm that makes n log n comparisons in average case for sorting an array of n elements. It is a faster and highly efficient sorting algorithm. This algorithm follows the divide and conquer approach. Divide and conquer is a technique of breaking down the algorithms into subproblems, then solving the subproblems, and combining the results back together to solve the original problem.

                    </p>
                  
                </div>
                <!-- <div class="sub-container">
                    <h1>Space Complexity</h1>
                    <p>Space complexity is a parallel concept to time complexity. If we need to create an array of size n, this will require O(n) space. If we create a two-dimensional array of size n*n, this will require O(n2) space.</p>
                </div> -->
            </td >
            <td style="vertical-align: top;">
                <img style="width:400px; margin-top:90px " src="https://www.happycoders.eu/wp-content/uploads/2020/07/Quicksort_runtime_for_various_optimizations-v2-944x613.png" alt="Girl in a jacket">
            </td>

        </tr>
       
       
    </table>
</div>


<div class="container-info">
    
    <table>
        <tr style="vertical-align: top; ">
            <td>
                <div class="sub-container ">
                    <h1>Merge Sort</h1>
                    <p style="font-family: 'Prompt', sans-serif; ">Merge sort is similar to the quick sort algorithm as it uses the divide and conquer approach to sort the elements. It is one of the most popular and efficient sorting algorithm. It divides the given list into two equal halves, calls itself for the two halves and then merges the two sorted halves. We have to define the merge() function to perform the merging.

                    </p>
                    <p>The sub-lists are divided again and again into halves until the list cannot be divided further. Then we combine the pair of one element lists into two-element lists, sorting them in the process. The sorted two-element pairs is merged into the four-element lists, and so on until we get the sorted list.</p>
                  
                </div>
                <!-- <div class="sub-container">
                    <h1>Space Complexity</h1>
                    <p>Space complexity is a parallel concept to time complexity. If we need to create an array of size n, this will require O(n) space. If we create a two-dimensional array of size n*n, this will require O(n2) space.</p>
                </div> -->
            </td >
            <td style="vertical-align: top;">
                <img style="width:400px; margin-top:90px " src="https://www.happycoders.eu/wp-content/uploads/2020/07/mergesort_runtime-944x549.png" alt="Girl in a jacket">
            </td>

        </tr>
       
       
    </table>
</div>

<div class="tail">
    <h2>SASHI.BHUMARAJU Â© 2022   </h2>
</div>